---
title: "Tarea 1"
author:
- José Ignacio Rojas Zárate, C16911
- Montserrat Beirute Abarca, C10997
- Valeria Vásquez Venegas, C18373
date: "`r format(Sys.Date(), '%d de %B de %Y', locale = 'es_ES')`"
output:
  pdf_document:
    toc: yes
    latex_engine: xelatex
    number_sections: true
    keep_tex: true
  html_document:
    theme: spacelab
    highlight: arrow
    toc: yes
    toc_float: yes
    lang: es-ES
subtitle: Estadística Actuarial II
header-includes:
  - \usepackage[spanish]{babel}
  - \usepackage{fontspec}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Introducción

El presente documento prestan el código y resultados a los ejercicios de la Tarea 1 del curso. Para su realización, se utilizó el programa R studio. 

Este trabajo requirió de los siguientes paquetes: 

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
#---Paquetes----------------------------------------------

library(stringr) # para cambiar todas las commas a puntos en la columna Ultimo Salario
library(ggplot2) # para hacer los gráficos
library(univariateML) # para hacer el análisis AIC
library(rriskDistributions) # para hacer el análisis AIC
library(boot) # para hacer el bootstrap
library(ks) # para Kernel smoothing
library(knitr) # para presentar mejor los datos en formato tabla
options(scipen = 999) # para no utilizar notación científica
library(cowplot) # para hacer graficos más atractivos
```

El presente trabajo utilizó la base de datos "BaseSalarios" brindada por el profesor Esteban Bermúdez Aguilar. A continuación se presenta el código para la lectura de la base de datos, así como también unos ajustes para poder manipular y extraer la información de los datos. 

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}

#---CSV y formatos-----------------------------------------

# Abrir y dar formato a la base de datos

base_salarios <- read.csv("BaseSalarios.csv",  sep = ";")

base_salarios$Fec.Nac <- as.Date(base_salarios$Fec.Nac, format = "%d/%m/%Y")

colnames(base_salarios)[5] ="Ultimo.Salario"

base_salarios <- subset(base_salarios, select = -X)

base_salarios$Ultimo.Salario <- as.numeric(str_replace_all(base_salarios$Ultimo.Salario, ",", "."))

```

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
base_salarios<- base_salarios[-84807, ]
base_salarios<- base_salarios[-96367, ]

base_salarios_temp <- base_salarios
base_salarios_temp$Ultimo.Salario <- format(base_salarios$Ultimo.Salario, big.mark = " ")

base_salarios_temp2 <- base_salarios
```

La base de datos tiene 5 columnas. A continuación, se presentan los primeros seis registros de la base de datos "BaseSalarios" para poder explicar la información de cada columna. 


```{r, echo=TRUE}
kable(head(base_salarios_temp), caption = "Primeros 6 registros de la base de datos", align = "r") 
```

La columna **ID** cuenta el número de registros disponibles, en este caso, se dispone de 106,002 registros. En la columna **Fec.Nac** se encuentra la información de la fecha de nacimiento de cada persona. En la tercera columna, **Sexo**, se observan los números 1 y 2; específicamente, si el valor de Sexo es 1, corresponde a hombres, y si es 2, corresponde a mujeres. La cuarta columna, **Cuotas** indica la cantidad de cuotas que cada persona ha aportado a un fondo de pensiones. Finalmente, la columna **Ultimo.Salario** contiene el último salario reportado, expresado en colones.  


Es importante señalar que se tomó la decisión de eliminar dos registros de la base de datos, ya que se consideraron datos atípicos, es decir, outliers. Estos dos registros correspondían a salarios de 13 199 892 y 13 110 539 colones y estaban asociados a individuos del género masculino. Ambos salarios superaban la media salarial de hombres en al menos 11 953 340 colones. 

```{r, eval=FALSE}

base_salarios <- base_salarios[-84807, ] # corresponde al salario 13 199 892
base_salarios <- base_salarios[-96367, ] # corresponde al salario 13 110 539

```
\newpage 

# Parte I

##  Análisis descriptivo de las variables Cuotas y Salarios con respecto a la variable Sexo

De las 106,000 personas que contiene la base de datos utilizada, el 69.1% son mujeres (73,279 mujeres). Por su parte, el 30.1% restante corresponde a hombres (32,721 hombres).


Es de interés conocer las diferencias o similitudes en los datos del número de cuotas y los salarios según el sexo. Para ello, se presenta el siguiente código:


```{r, echo=TRUE,results='asis', message=FALSE, warning=FALSE}

resumen_cuotas_hombres <-summary(base_salarios$Coutas[base_salarios$Sexo == 1])

varianza_cuotas_hombres <- var(base_salarios$Coutas[base_salarios$Sexo == 1])

resumen_cuotas_hombres <- c(resumen_cuotas_hombres, Varianza = varianza_cuotas_hombres)

resumen_cuotas_mujeres <-summary(base_salarios$Coutas[base_salarios$Sexo == 2])

varianza_cuotas_mujeres <- var(base_salarios$Coutas[base_salarios$Sexo == 2])

resumen_cuotas_mujeres <- c(resumen_cuotas_mujeres, Varianza = varianza_cuotas_mujeres)

cuotas_resumen <- data.frame(
  Estadistico = c("Mínimo", "Primer cuartil (Q1)", "Mediana", "Promedio", "Tercer cuartil (Q3)", "Máximo", "Varianza"),
  Hombres = as.numeric(round(resumen_cuotas_hombres,2)),
  Mujeres = as.numeric(round(resumen_cuotas_mujeres,2))
)

```

A continuación, se presenta un cuadro con un resumen estadístico de los datos del número de cuotas para hombres y mujeres.

```{r, echo=FALSE}
kable(cuotas_resumen, caption = "Resumen estadístico de número de coutas por sexo")
```

Como se puede observar, tanto para mujeres como para hombres, el número mínimo de cuotas aportadas es tan solo una.

En general, y se va a justificar a continuación, se puede decir que las mujeres en la base de datos han aportado más cuotas que los hombres.

Se puede notar que el 25% de los hombres aportó 61 cuotas o menos, mientras que en el caso de las mujeres, el 25% aportó 66 cuotas o menos.
 
Además, el 50% de las mujeres aportó más de 135 cuotas, mientras que en el caso de los hombres, fue de 124 cuotas.

El promedio de cuotas es más alto para las mujeres (142.97) que para los hombres (135.19). 

También, el 75% de las mujeres aportó 213 cuotas o menos, mientras que en el caso de los hombres, fue de 198 cuotas. 

El valor máximo de cuotas aportadas para las mujeres fue de 373, mientras que para los hombres fue de 371.

Es importante resaltar que para ambos sexos, la varianza indica que los datos están alejados de la media y se presenta mucha variabilidad en los datos de número de cuotas aportadas al fondo de pensiones. 

Además, a continuación, se muestra el código y un cuadro con un resumen estadístico de los datos del último salario reportado tanto para hombres como para mujeres.

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}

resumen_salarios_hombres <-summary(base_salarios$Ultimo.Salario[base_salarios$Sexo == 1])

varianza_salarios_hombres <- var(base_salarios$Ultimo.Salario[base_salarios$Sexo == 1])

resumen_salarios_hombres <- c(resumen_salarios_hombres, Varianza = varianza_salarios_hombres)

resumen_salarios_mujeres <-summary(base_salarios$Ultimo.Salario[base_salarios$Sexo == 2])

varianza_salarios_mujeres <- var(base_salarios$Ultimo.Salario[base_salarios$Sexo == 2])

resumen_salarios_mujeres <- c(resumen_salarios_mujeres, Varianza = varianza_salarios_mujeres)

salarios_resumen <- data.frame(
  Estadistico = c("Mínimo", "Primer cuartil (Q1)", "Mediana", "Promedio", "Tercer cuartil (Q3)",
                  "Máximo", "Varianza"),
  Hombres = format(as.numeric(round(resumen_salarios_hombres,2)),big.mark = " "),
  Mujeres = format(as.numeric(round(resumen_salarios_mujeres,2))
,big.mark = " "))

```

```{r, echo=FALSE}
kable(salarios_resumen, caption = "Resumen de Último Salario reportado por sexo", align = "r")
```

En el Cuadro 3, se observa que el salario más bajo reportado le pertenece a una mujer, siendo tan solo 656.93 colones menos que el salario más bajo de los hombres. 

En cuanto al Q1, se destaca que el 25% de los hombres tuvieron un último salario reportado de 552,491 colones o menos, mientras que el 25% de las mujeres tuvieron un último salario de 584,757 colones o menos. Es decir, en los últimos salarios más bajos, las mujeres experimentaron ingresos superiores a los de los hombres.

Ahora en relación a la mediana, la mitad de los hombres ganó más de 1 104 956 colones, mientras que la mitad de las mujeres ganó menos (1 046 661 colones). 

Además, el promedio de los últimos salarios fue mayor para los hombres, aproximadamente 109 807 colones más alto.

Las diferencias se incrementan a medida que se consideran los últimos salarios más altos. El 75% de las mujeres ganaron 1 403 025.79 o menos, mientras que el 75% de los hombres ganaron 1 611 735 colones o menos. 

El salario máximo reportado por hombres es 864 755 colones más alto que el de las mujeres. 

Es importante resaltar que la varianza para ambos sexos señala que los datos están muy dispersos de la media, es decir hay una gran variabilidad en los datos de último salario reportado. 


## Gráfico plotbox para el salario para comparar entre las categorías de Sexo

El siguiente gráfico plotbox permite tener una representación visual de como se distribuyen los datos para cada sexo. 

```{r, echo=FALSE}
base_salarios_temp2$Sexo <- factor(base_salarios$Sexo, levels = c(1, 2), labels = c("Hombre", "Mujer"))

boxplot_salarios <- ggplot(base_salarios_temp2, aes(x = Sexo, y = Ultimo.Salario, fill = Sexo)) +
  geom_boxplot() +
  theme_cowplot() +
  scale_x_discrete(labels = c("Hombre", "Mujer")) +
  scale_fill_manual(values = c("Hombre" = "seagreen", "Mujer" = "lightblue")) +
  labs(x = "Sexo", y = "Ultimo salario reportado en miles de colones") +
  scale_y_continuous(breaks = seq(0, 15000000, by = 1000000), labels =   scales::comma_format(scale = 1e-3)) + ggtitle("Boxplot de Ultimo Salario por Sexo")

print(boxplot_salarios)
```

Este gráfico destaca la presencia de salarios atípicos, identificados como aquellos que están fuera de cada una de las cajas. Además, en este gráfico, es de utilidad para visualizar el análisis presentado en la sección anterior. 


## Conclusiones con respecto a los salarios y sexo

Después de realizar el análisis descriptivo de los datos y para complementar el gráfico anterior, se concluye que al dividir la población por sexo, el 25% de los hombres con los salarios más bajos ganan menos que el 25% de las mujeres con salarios más bajos. Sin embargo, cuando se considera el 50% de los hombres que ganan más, estos perciben un salario mayor que el 50% de las mujeres que ganan más. Esta tendencia se evidencia claramente en el gráfico anterior, donde la parte superior de la caja, que está por encima de la línea de la mediana, es más amplia en el caso de los hombres.


Para respaldar este argumento, se observa que el promedio de los últimos salarios fue mayor para los hombres, aproximadamente 109 807 colones más alto que el de las mujeres.

No obstante, es importante señalar que la varianza de los salarios es mayor para los hombres, y los valores atípicos en los salarios masculinos también son más altos que los de las mujeres.

En este sentido, los salarios de los hombres parecen ser relativamente más altos que los de las mujeres, aunque las diferencias no resultan significativas. Ambos tienen personas con salarios más altos que la mayoría. 


## Prueba de hipótesis sobre las medias de las categorías de sexo

En relación a las medias, se cree que las medias de los salarios para hombres y mujeres son diferentes.
Para verificar lo expresado anteriormente, se llevó a cabo la siguiente prueba de hipótesis. 

En este caso, se llevó a cabo un **Welch Two Sample t-test**, la cual es una prueba estadística que permite comparar las medias de dos muestras. En este caso, el tamaño de las muestras y sus varianzas difieren. 

Para realizar una prueba de hipótesis se necesitan tres cosas: la hipótesis nula (H0), el estadístico de prueba (t) y la distribución del estadístico de prueba. 

En este caso particular: 

1. H0: La diferencia entre la media de los últimos salarios de los hombres y la media de los últimos salarios de las mujeres es 0.
2. El estadístico de prueba es t, el cual se puede calcular de la siguiente manera: \[ t = \frac{\bar{X}_1 - \bar{X}_2}{\sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}} \]
donde \( \bar{X}_1 \) y \( \bar{X}_2 \) son las medias de cada una de las muestras,
\( s_1 \) y \( s_2 \) son las desviaciones estándar de los dos muestras,
\( n_1 \) y \( n_2 \) son el tamaño de cada una de las muestras. 
3. Por último, el estadístico t sigue una distribución t con \( v \) grados de libertad, la cual se calcula utilizando la equación Welch–Satterthwaite.

A continuación se presenta el código de la prueba y la interpretación de los resultados:

```{r, results='markup'}
t.test(
  x           = base_salarios$Ultimo.Salario[base_salarios$Sexo == 1],
  y           = base_salarios$Ultimo.Salario[base_salarios$Sexo == 2],
  paired      = FALSE,
  alternative = "two.sided",
  conf.level  = 0.95
)
```

El p-valor lo que dice es si se asume la H0 como verdadera, la probabilidad de que H0 sea verdadera. En este caso, el valor p fue menor a \( 0.00000000000000022
\) lo cual es muy cercano a 0, es decir, hay una probabilidad muy pequeña de que la media de los últimos salarios entre hombres y mujeres sea 0, es decir, que sea la misma. Por tanto, existe suficiente evidencia para rechazar la hipotesis nula. 

\newpage 
# Parte II

## Construcción del histograma de los salarios

A continuación, se presenta el histograma de los salarios de la base de datos. Se decidió dividir los salarios en 30 grupos (30 rectángulos). El histograma evidencia una cantidad reducida de salarios bajos. Luego, se puede observar que la gran mayoría de las personas se encuentran entre el rectángulo dos y el rectángulo seis. En particular, el rectángulo seis es el que contiene más registros y señala que se trata de salarios menores a 1 820 000 colones. 

```{r, echo=TRUE}

grafBase <- ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = (max(base_salarios$Ultimo.Salario) -
                               min(base_salarios$Ultimo.Salario)) / 29, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  labs(title = "Histograma de los últimos salarios reportados", 
       x = "Salario en miles de colones", 
       y = "Frecuencia") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3))

grafBase

```

## Densidad de los salarios por kernel (no paramétrica)

Una forma de aproximar la densidad de una muestra es mediante el uso de kernels. Existen diversos tipos de kernels, como el kernel normal, kernel epanechnikov, kernel triangular, kernel coseno y kernel rectangular. A continuación, se presentan los gráficos de la densidad de los salarios utilizando cada uno de estos tipos de kernels mediante la función Density en el programa R.

### Densidad de los salarios por kernel usando como kernel Biweigth 

```{r, echo=TRUE, warning=FALSE}
density_biweight <- density(base_salarios$Ultimo.Salario, kernel = "biweight")

```

```{r, echo=TRUE, warning=FALSE, eval=FALSE}
grafBase <- grafBase +
  geom_line(data = data.frame(x = density_biweight$x, y = density_biweight$y),
            aes(x, y), color = "cyan4", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ", 
       subtitle = "con Kernel Biweight", x = "Salario en miles de colones", y = "Densidad")
```

```{r, echo=FALSE, warning=FALSE}
ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_biweight$x, y = density_biweight$y),
            aes(x, y), color = "cyan4", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       subtitle = "con Kernel Biweight", x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3))
```

### Densidad de los salarios por kernel usando como kernel Normal

```{r, echo=TRUE, warning=FALSE}
density_normal <- density(base_salarios$Ultimo.Salario,kernel = "gaussian")

```

```{r, echo=TRUE, warning=FALSE, eval=FALSE}
grafBase <- grafBase +
  geom_line(data = data.frame(x = density_normal$x, y = density_normal$y),
            aes(x, y), color = "red3", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ", 
       subtitle = "con Kernel Normal", x = "Salario en miles de colones", y = "Densidad")
```

```{r, echo=FALSE, warning=FALSE}
ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_normal$x, y = density_normal$y),
            aes(x, y), color = "red3", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ", 
       subtitle = "con Kernel Normal", x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3)
  )

```


### Densidad de los salarios por kernel usando como kernel Epanechnikov

```{r, echo=TRUE, warning=FALSE}
density_epanechnikov <- density(base_salarios$Ultimo.Salario,kernel = "epanechnikov")

```

```{r, echo=TRUE, warning=FALSE, eval=FALSE}
grafBase <- grafBase +
  geom_line(data = data.frame(x = density_epanechnikov$x, y = density_epanechnikov$y),
            aes(x, y), color = "seagreen", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       subtitle = "con Kernel Epanechnikov", x = "Salario en miles de colones", y = "Densidad")
```

```{r, echo=FALSE, warning=FALSE}

ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_epanechnikov$x, y = density_epanechnikov$y),
            aes(x, y), color = "seagreen", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       subtitle = "con Kernel Epanechnikov", x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3)
  )

```

### Densidad de los salarios por kernel usando como kernel Coseno

```{r, echo=TRUE, warning=FALSE}
density_coseno <- density(base_salarios$Ultimo.Salario,kernel = "cosine")
```

```{r, echo=TRUE, warning=FALSE, eval=FALSE}
grafBase <- grafBase +
  geom_line(data = data.frame(x = density_coseno$x, y = density_coseno$y),
            aes(x, y), color = "hotpink1", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       subtitle = "con Kernel Coseno", x = "Salario en miles de colones", y = "Densidad")
```

```{r, echo=FALSE, warning=FALSE}
ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_coseno$x, y = density_coseno$y),
            aes(x, y), color = "hotpink1", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       subtitle = "con Kernel Coseno", x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3)
  )

```


### Densidad de los salarios por kernel usando como kernel Rectangular

```{r, echo=TRUE, warning=FALSE}
density_rectangular <- density(base_salarios$Ultimo.Salario,kernel = "rectangular")
```

```{r, echo=TRUE, warning=FALSE, eval=FALSE}
grafBase <- grafBase +
  geom_line(data = data.frame(x = density_rectangular$x, y = density_rectangular$y),
            aes(x, y), color = "goldenrod2", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",
       
       subtitle = "con Kernel Rectangular", x = "Salario en miles de colones", y = "Densidad")
```

```{r, echo=FALSE, warning=FALSE}

ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_rectangular$x, y = density_rectangular$y),
            aes(x, y), color = "goldenrod2", size = 1) +  
  labs(title = "Densidad de los últimos salarios reportados ",subtitle = "con Kernel Rectangular", x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3)
  )

```

### Densidad de los salarios con todos los kernel

En el siguiente gráfico, se colocó todos los kernel en un sólo gráfico. En este gráfico lo que se puede observar es que la gráfica de kernel epanechnikov es la que más se distancia del resto de las gráficas. 


```{r, echo=TRUE, warning=FALSE}

ggplot(base_salarios, aes(x = Ultimo.Salario)) +
  geom_histogram(binwidth = 150000, fill = "lightblue", color = "black", alpha = 0.7, 
                 aes(y = ..density..)) +
  geom_line(data = data.frame(x = density_normal$x, y = density_normal$y),
            aes(x, y, color = "Normal"), size = 2) +
  geom_line(data = data.frame(x = density_biweight$x, y = density_biweight$y),
            aes(x, y, color = "Biweight"), size = 1.7) +
  geom_line(data = data.frame(x = density_coseno$x, y = density_coseno$y),
            aes(x, y, color = "Coseno"), size = 1.4) +
  geom_line(data = data.frame(x = density_rectangular$x, y = density_rectangular$y),
            aes(x, y, color = "Rectangular"), size = 1.1) +
  geom_line(data = data.frame(x = density_epanechnikov$x, y = density_epanechnikov$y),
            aes(x, y, color = "Epanechnikov"), size = 0.8) +
  labs(title = "Densidad de los últimos salarios reportados", 
       x = "Salario en miles de colones", y = "Densidad") +
  theme_cowplot() +
  scale_x_continuous(
    breaks = seq(min(base_salarios$Ultimo.Salario), max(base_salarios$Ultimo.Salario), 
                 length.out = 10),
    labels = scales::label_number(big.mark = " ", decimal.mark = ".", scale = 1e-3)
  ) +
  scale_color_manual(values = c("red3", "cyan4", "hotpink1", "goldenrod2", "seagreen"),
                     name = "Kernel",
                     labels = c("Normal", "Biweight", "Coseno", "Rectangular", 
                                "Epanechnikov")) +
  theme(legend.text = element_text(size = 6),
        legend.title = element_text(size = 9))

```



# Parte III


El Criterio de Información de Akaike (AIC) es una medida utilizada en estadísticas y modelado para comparar modelos estadísticos.El AIC se calcula utilizando la siguiente fórmula:

\[ AIC= 2*N−2*log(L) \]

Donde \[L\] representa la funcion de máxima verosimilitud del modelo y \[N\] representa el número de parámetros en el modelo. El modelo penaliza aquellos modelos que utilizan varios parámetros, ya que se busca el modelo con mayor simpleza. Cuando se comparan varios modelos, el modelo con el AIC más bajo se considera preferido.

## Análisis del AIC de la variable Ultimo.Salario mediante la función model_select
```{r, results='markup'}
model_select(base_salarios$Ultimo.Salario)
```

Vemos que la funcion model select del paquete univariateML sugiere una distribución t-student para representar los datos de Ultimo.Salario.

## Análisis del AIC de la variable Ultimo.Salario mediante la función fit.cont
```{r, eval=FALSE}

fit.cont(base_salarios$Ultimo.Salario)
```

```{r, echo=FALSE}
fit.cont.resultados <- data.frame(
  Distribución = c("Cauchy", "Uniforme", "Lognormal","Weibull", "F","Student"),
  AIC = c("3 158 816.91","NULL" ,"3 119 863.45", "3 104 610.52", "3 705 605.8", "3 850 227.82")
)

```

```{r, echo=FALSE}
knitr::kable(fit.cont.resultados)
```

Bajo el criterio de AIC, el modelo con el valor más bajo es el Weibull, seguido por el Lognormal con una diferencia de 115 252.93 unidades. En comparación, la diferencia entre el Weibull y la distribución t que fue la que el fit.cont() recomendaba, es de 745 617.3 unidades. Es por este motivo, que al comparar ambos resultados, se opta por el modelo Weibull para representar los salarios. 




## Construcción de un intervalo de confianza para la media y la desviación estándar usando la función bootstrapml
```{r, results='markup'}
#Creamos un objeto de distribución
distribucionml <- mlweibull(base_salarios$Ultimo.Salario)

bootstrapml(distribucionml, 
            map = function(x) mean(x))
```

Es decir, con una confianza del 95%, al aplicar bootstrapml, se estima que la media de la distribución Weibull, está entre los 606 922.4 colones y los 611 076.8 colones. 


```{r, results='markup'}

bootstrapml(distribucionml, 
            map = function(x) sd(x))
```

Por su parte, la desviación estándar de la distribución Weibull al aplicar el bootstrapml está entre  858 674.9 y 864 239.7.

# Parte IV

## Estimación de la densidad del kernel

La función kde(Kernel Density Estimation) del paquete ks en R,c omo su nombre indica, lleva a cabo una estimación no paramétrica de la densidad de kernel para datos de 1 hasta 6 dimensiones. Esta función se utiliza comúnmente cuando la función de distribución de los datos es irregular, ya que, kde() genera una función suavizada de la misma.


```{r, echo=TRUE, warning=FALSE}
plot(kde(base_salarios$Ultimo.Salario),  main = "Densidad de Kernel para los Salarios", xlab = "Monto del Salario", ylab= "Función de Densidad", col = "cyan4", lwd = 2, las = 1, cex.axis=0.5, cex.lab = 0.8)


```

## Intervalos de confianza con bootstrap

La función boot.ci del paquete boot en R se utiliza para calcular los intervalos de confianza de un estadístico determinado, para lo cual la función realiza un remuestreo bootstrap del estadístico con la muestra de datos proporcionada. Esta función calcula los intervalos de confianza mediante 4 métodos diferentes de bootstrap: básico, 'studentized', de percentiles y de percentiles ajustados.


## Bootstrap de la media de los salarios

### Estimación de la media del Bootstrap

En este caso, se consideran 1000 muestras bootstrap y se calcula la media para cada una de las muestras. 


```{r, results='markup'}
set.seed(123) #  generar números aleatorios

bootstrap <- boot(data = base_salarios$Ultimo.Salario, 
                  statistic = function(x, indices) mean(x[indices]), R=1000)
mean(bootstrap$t)
bootstrap$t0 

```
La media de los últimos salarios al aplicar bootstrap es de  1 080 550 colones, mientras que la media de los datos originales fue de 1 080 558. Es decir, la diferencia entre estas es de 8 colones. 

```{r, results='markup'}
boot.ci(bootstrap, conf = 0.95, type = "basic")
```

Con un nivel de confianza del 95%, la media de los salarios de la base de datos está entre 1 076 945 y 1 084 276 colones al aplicar bootstrap. 

### Histograma de los resultados

En el siguiente histograma se presentan los resultados del Bootstrap. 
```{r, echo=TRUE, warning=FALSE}
hist(bootstrap$t, las=1, main="Histograma de las medias de salarios", xlab="Media Bootstrap", ylab="Frecuencia", col="lightblue")



```